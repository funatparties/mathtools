from sympy.ntheory import divisors
from sympy.functions.combinatorial.numbers import totient
from sympy.combinatorics import CyclicGroup, Coset, PermutationGroup, Permutation
from collections import namedtuple

QuotientGroup = namedtuple('QuotientGroup', 'G1, G2, order')
# n_phi is the number of isomorphisms that exist
GoursatTuple = namedtuple('GoursatTuple', 'G1, G2, H1, H2, n_phi')


def subgroups_of_cycle_product(n: int, m: int):
    """
    Compute the subgroups of a direct product of two cyclic groups with orders
    n and m.

    Algorithm by using Goursat's lemma and properties of cyclic groups.

    Ref: https://math.stackexchange.com/questions/485512/subgroups-of-a-direct-product
    """
    quotients_a = subquotients(n)
    quotients_b = subquotients(m)
    # find all pairs with equal order
    pairs = [(a,b) for a in quotients_a for b in quotients_b if a.order == b.order]
    # create tuples
    tuples = [GoursatTuple(a.G1, a.G2, b.G1, b.G2, totient(a.order)) for (a,b) in pairs]
    # TODO: convert to subgroups
    return tuples


def subquotients(n: int):
    """
    Find the subquotients of a cycle group of order n.
    """
    return [QuotientGroup(a, b, a//b) for a in divisors(n) for b in divisors(a)]


def subgroups_from_tuple(G1: PermutationGroup, G2: PermutationGroup, H1: PermutationGroup, H2: PermutationGroup):
    """
    Initially:
        Select generator of G1 g.
        Identify all generators of H1 in distinct cosets of H2.
        generators will all be of the form h^a where h is a generator and a is coprime to the order of H1.
    There should be a number of these equal to the number of isomorphisms from G1/G2 -> H1/H2
    For each isomorphism G1/G2 -> H1/H2 that exists:
        Select isomorphism f by selecting a generator h of H1 to map g onto.
        Generate cosets of G2 by multiplying by g.
        Pair them with the cosets of H2 generated by multiplication by h.
        (i.e. f((g^n)G2) = (h^n)H2 for all n).
        Enumerate all pairs of elements in each pair of cosets.
    """
    assert G1.is_cyclic and H1.is_cyclic, "Groups must be cyclic"
    g: Permutation = G1.generators[0]
    h: Permutation = H1.generators[0]
    # TODO: enumerate other generators for the other isomorphisms
    n = H1.order()
    coset_maps = dict()
    index = G1.order()//G2.order()
    # iterating up to index should generate all cosets
    for i in range(index):
        k = Coset(g**i,G2,G1)
        v = Coset(h**i,H2,H1)
        print(f'Mapping {k} to {v}')
        coset_maps[k] = v
    # make sure the cosets cover the whole group
    coset_coverage = {e for coset in coset_maps.keys() for e in coset.as_list()}
    assert coset_coverage == set(G1.elements), "Failure generating cosets of G2 in G1"

    elements = []
    for k,v in coset_maps.items():
        pairs = [(a,b) for a in k.as_list() for b in v.as_list()]
        elements.extend(pairs)
    return elements

def test():
    G1 = CyclicGroup(4)
    G2 = G1.subgroup_search(lambda x: x.order() == 2)
    H1 = CyclicGroup(2)
    H2 = H1.subgroup_search(lambda x: x.order() == 1)
    return subgroups_from_tuple(G1,G2,H1,H2)



def subgroups_of_cycle_order(n: int):
    """
    Return a dictionary of all subgroups of the cyclic group of order n.
    Dict keys are the group orders and values are the permutation groups.
    Includes the trivial group and entire group.
    """
    return subgroups_of_cycle(CyclicGroup(n))


def subgroups_of_cycle(G: PermutationGroup) -> dict[int, PermutationGroup]:
    """
    Return a dictionary of all subgroups of the given cyclic group G.
    Dict keys are the group orders and values are the permutation groups.
    Includes the trivial group and G itself.
    """
    assert G.is_cyclic, "G must be a cyclic group"
    d = dict()
    # subgroups are all cycles with order that divide the group order
    for i in divisors(G.order()):
        d[i] = G.subgroup_search(lambda x: x.order() == i)
    return d


def enumerate_cosets(G: PermutationGroup, H: PermutationGroup) -> list[Coset]:
    """
    Generate an explicit list of cosets of H in G.
    Includes H itself.
    """
    representatives = G.coset_transversal(H)
    cosets = []
    for g in representatives:
        cosets.append(Coset(g,H,G))
    return cosets

